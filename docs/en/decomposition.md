# Методология блочной декомпозиции

Как разбивать бизнес-задачу на блоки для khorsyio.

## Алгоритм декомпозиции

### Шаг 1. Определи границы процесса

Вход: что приходит от пользователя или триггера
Выход: что должно получиться в итоге
Источник: http, websocket, scheduler, другой handler

### Шаг 2. Выдели этапы обработки

Задай вопрос: какие логически отдельные действия происходят между входом и выходом? Каждое действие которое можно описать одним предложением - кандидат на блок.

Признаки что это отдельный блок
- У действия своя ответственность (валидация, расчет, проверка, сохранение)
- Действие может быть заменено другой реализацией
- Действие может быть переиспользовано в другом процессе
- Действие обращается к отдельному ресурсу (другая таблица, внешний сервис)

Признаки что действия должны быть в одном блоке
- Действия всегда выполняются вместе и не имеют смысла по отдельности
- Между ними нет логической границы
- Разделение не добавляет ясности

### Шаг 3. Определи структуры

Для каждого блока определи: что он получает, что возвращает. Это msgspec.Struct.

Два паттерна структур

**Паттерн Pipeline (единый state)**. Один struct обогащается по мере прохождения. Каждый блок дописывает свои поля.

```python
class OrderState(msgspec.Struct):
    # входные данные (заполняет первый блок)
    product: str = ""
    quantity: int = 0
    # данные от PriceHandler
    unit_price: float = 0
    subtotal: float = 0
    # данные от DiscountHandler
    discount_pct: float = 0
    total: float = 0
    # данные от StockHandler
    stock_reserved: bool = False
    # статус прохождения
    status: str = ""
    steps: list = msgspec.field(default_factory=list)
```

Когда использовать: линейные цепочки где каждый этап обогащает общий результат. Удобно для трассировки - видно весь путь.

**Паттерн Transform (вход/выход)**. Каждый блок имеет свой input и output struct.

```python
class RawData(msgspec.Struct):
    records: list = msgspec.field(default_factory=list)

class Aggregated(msgspec.Struct):
    count: int = 0
    total: float = 0
    average: float = 0

class Formatted(msgspec.Struct):
    title: str = ""
    body: str = ""
```

Когда использовать: этапы с разной природой данных. Вход и выход существенно отличаются. Блоки более переиспользуемы.

### Шаг 4. Нарисуй граф событий

```
input_event -> handler_1 -> event_a -> handler_2 -> event_b -> handler_3 -> output_event
```

Проверь что
- Каждое опубликованное событие имеет подписчика
- Нет циклов (если не нужны специально)
- Финальное событие либо ловится bus.request, либо обрабатывается терминальным блоком

### Шаг 5. Определи namespace

Если блоки принадлежат одному бизнес-процессу, объедини в Domain с namespace.

```python
order = Domain()
order.namespace = "order"
order.handlers = [ValidateHandler, PriceHandler, ...]
```

События станут order.validate, order.priced и т.д.

## Примеры декомпозиции

### Пример: регистрация пользователя

Задача: пользователь шлет email + password, система регистрирует.

Этапы
1. Валидация (формат email, длина пароля)
2. Проверка уникальности (email не занят)
3. Хэширование пароля
4. Сохранение в базу
5. Отправка welcome email

```
user.validate -> user.check_unique -> user.hash_password -> user.save -> user.notify
```

Структуры

```python
class RegisterIn(msgspec.Struct):
    email: str = ""
    password: str = ""

class UserState(msgspec.Struct):
    email: str = ""
    password: str = ""
    password_hash: str = ""
    user_id: int = 0
    status: str = ""
    steps: list = msgspec.field(default_factory=list)
```

Блоки 1-4 используют паттерн Pipeline (единый UserState). Блок 5 (notify) - терминальный, publishes="" потому что ничего не ждет ответа.

### Пример: обработка платежа

Этапы
1. Валидация карты
2. Проверка лимитов
3. Фрод-проверка
4. Списание через gateway
5. Обновление баланса
6. Генерация чека

```
payment.validate_card -> payment.check_limits -> payment.fraud_check -> payment.charge -> payment.update_balance -> payment.receipt
```

Блок fraud_check может использовать условную маршрутизацию: если подозрительно, публикует payment.review вместо payment.charge.

### Пример: ETL pipeline (worker)

Scheduled task каждый час. Нет http.

```
etl.extract -> etl.transform -> etl.validate -> etl.load -> etl.notify
```

Блоки используют паттерн Transform: Extract возвращает RawRows, Transform возвращает CleanRows, Validate возвращает ValidatedRows, Load возвращает LoadResult.

### Пример: чат с модерацией (websocket)

```
chat.message -> chat.moderate -> chat.enrich -> chat.broadcast
```

moderate проверяет на запрещенный контент. enrich добавляет timestamp, username. broadcast рассылает через transport.

## Правила хорошего блока

1. Один блок - одна ответственность. Если описание блока содержит "и", скорее всего его надо разделить.

2. Блок не знает кто до него и кто после. Он работает только со своим входом и контекстом.

3. Блок idempotent по возможности. Повторный вызов с тем же входом дает тот же результат.

4. Ошибки обрабатываются явно. Либо через статус в struct, либо через exception. Не молча проглатываются.

5. Блок логирует свою работу через ctx.trace_id. Это позволяет отследить весь путь запроса.

6. Timeout адекватен задаче. Быстрый расчет - 5s. Вызов внешнего API - 30s. Тяжелый ETL - 120s.

7. Структуры определяются до логики. Сначала контракт, потом реализация.

## Антипаттерны

**God handler** - блок который делает все. Если process длиннее 30 строк, подумай о разделении.

**Скрытая связность** - блок напрямую импортирует и вызывает другой блок. Используй события.

**Неявный контракт** - блок принимает dict вместо struct. Теряется валидация и документация.

**Глобальное состояние** - блок пишет в глобальную переменную. Используй struct или базу.

**Игнорирование статуса** - блок не проверяет статус от предыдущего. В pipeline каждый блок должен проверить что предыдущий этап прошел.

**Неявные транзакции (DML без commit)** - использование `fetchrow` / `fetchval` для `INSERT/UPDATE ... RETURNING` без ручного коммита или патча `begin()`. Всегда используй `await db.execute` для DML или пропатченные методы.

**Перекрытие роутов** - регистрация маршрутов с одинаковой структурой, но разными методами (например, `PUT /users/{id}` и `GET /users/{slug}`). Это приводит к ошибкам маршрутизатора 404/405. Статические и защищенные маршруты должны быть объявлены раньше.

**Глобальный Event Loop в тестах** - фикстуры `pytest` с запущенным `app.bus` (где создается `asyncio.Queue`) в `session` scope ломают последующие тесты. Фикстуры `app`/`client` должны быть уровня `function`.

**Неверный тип JWT sub** - PyJWT 2.x+ отклонит `sub` типа `int`. Конвертируй идентификатор: `str(user_id)`.
